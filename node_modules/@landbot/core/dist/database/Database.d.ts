import { AuthData, ConfigProperties, Messages } from '../types';
export declare class Database {
    private firebaseApp;
    /**
     * Defined when the customer is identified. It's a chat reference, used
     * for data base reading and listening purposes.
     * @type {Object}
     */
    private chatRef;
    /**
     * Defined when the customer is identified. The reference stores the
     * "online" status of a customer.
     * @type {Object}
     */
    private statusRef;
    /**
     * Defined to get a "real" database timestamp.
     * @type {Number}
     */
    private lastTimestamp;
    /**
     * Useful to get iteratively older messages.
     * @type {Number}
     */
    private firstTimestamp;
    /**
     * New message handler. Binded to be easily removed on destroy.
     * @type {Function}
     */
    private newMessageListener;
    /**
     * Connection change handler. Binded to be easily removed on destroy.
     * @type {Function}
     */
    connectionChangeListener: any;
    constructor(core: any, firebase: any);
    /**
     * Initialization task.
     *
     * @param {Core} core
     * @param {Object} firebase Firebase library.
     * @memberof Database
     */
    private _init;
    /**
     * Authentication task.
     *
     * @param {Object} data Authentication needed data.
     * @returns {Promise} returns the same coming data for next handlers.
     * @memberof Database
     */
    auth(data: AuthData): Promise<AuthData>;
    /**
     * Request auth information.
     *
     * @param {Object} data Authentication request needed data.
     * @returns {Object}
     * @memberof Database
     */
    authRequest({ customerToken, channelToken, serverUrl, }: Partial<ConfigProperties>): Promise<AuthData>;
    /**
     * Destroy database instance.
     *
     * @memberof Database
     */
    destroy(): Promise<any>;
    /**
     * Sets chat messages reference.
     *
     * @param {String} path
     * @memberof Database
     */
    setChatReference(path: string): void;
    /**
     * Sets status reference and corresponding listeners.
     *
     * @param {String} path
     * @memberof Database
     */
    setStatusReference(path: string): void;
    /**
     * Sets on change connection callback.
     *
     * @returns {Promise}
     * @memberof Database
     */
    setConnectionTrackingListener(callback: (boolean: any) => void): Promise<void>;
    /**
     * Unsets on new message received callbacks.
     *
     * @returns {Promise}
     * @memberof Database
     */
    unsetConnectionTrackingListener(): Promise<void>;
    /**
     * Sets on new message received callback.
     *
     * @returns {Promise}
     * @memberof Database
     */
    setNewMessageListener(callback: (Message: any) => void): Promise<void>;
    /**
     * Unsets on new message received callbacks.
     *
     * @returns {Promise}
     * @memberof Database
     */
    unsetNewMessageListener(): Promise<void>;
    /**
     * Get last messages from database if any.
     *
     * @param {Number} [amount=20] Amount of messages to be retrieved.
     * @returns {Promise} Resolves with retrieved messages.
     * @memberof Database
     */
    getLastMessages(amount?: number): Promise<Messages>;
    /**
     * Get more messages from database from:
     * (firstTimestamp - 20 messages) to firstTimestamp
     *
     * @param {Number} [amount=20] Amount of messages to be retrieved.
     * @returns {Promise} Resolves with retrieved messages.
     * @memberof Database
     */
    getMoreMessages(amount?: number): Promise<Messages>;
    /**
     * Firebase create an internal iframe before opening websockets.
     * When running inside a sandboxed iframe it casues some errors that can be avoided with this method.
     * This method is not documented so we should not relay too much on it.
     *
     * @memberof Database
     */
    forceWebSockets(): boolean;
    /**
     * Updates first timestamp with a given list of messages.
     *
     * @param {Object} messages
     * @memberof Database
     */
    private _updateFirstTimestamp;
}
